<?php

/**
 * @file
 * Unit tests for the Commerce License Billing module.
 */

/**
 * Test the product and product type CRUD.
 */
class CommerceLicenseBillingTestCase extends CommerceBaseTestCase {

  protected $profile = 'testing';

  protected $billing_cycle_type = NULL;
  protected $billing_cycle = NULL;
  protected $prepaid_product = NULL;
  protected $prepaid_product_display = NULL;
  protected $postpaid_product = NULL;
  protected $alternative_postpaid_product = NULL;
  protected $postpaid_product_display = NULL;

  public static function getInfo() {
    return array(
      'name' => 'Commerce License Billing',
      'description' => 'Test recurring billing for licenses.',
      'group' => 'Commerce License',
    );
  }

  public function setUp() {
    // Install all required modules, and clear the cache so that the required
    // license & billing fields are created
    $modules = parent::setUpHelper('ui');
    $additional_modules = array('commerce_payment_example', 'commerce_license_billing', 'commerce_license_billing_test');
    $modules = array_merge($modules, $additional_modules);
    parent::setUp($modules);

    // Enable licensing on the required product and line item types.
    variable_set('commerce_license_product_types', array('product' => 'product'));
    variable_set('commerce_license_line_item_types', array('product' => 'product'));

    // Flush the caches to trigger the creation of the license & billing fields.
    drupal_flush_all_caches();

    $this->createDummyProductDisplayContentType();
    $this->store_customer = $this->createStoreCustomer();
    // Create a test billing cycle type.
    $billing_cycle_type = entity_create('cl_billing_cycle_type', array('engine' => 'test'));
    $billing_cycle_type->name = 'Test';
    $billing_cycle_type->title = 'test';
    $billing_cycle_type->save();
    $this->billing_cycle_type = $billing_cycle_type;
    $this->billing_cycle = $billing_cycle_type->getBillingCycle($this->store_customer->uid);

    // Create a prepaid product that holds the license.
    $this->prepaid_product = $this->createProduct('PREPAID-LICENSE', 50, 'prepaid');
    // Create a product display for the prepaid product.
    $node = (object) array('type' => 'product_display');
    node_object_prepare($node);
    $node->uid = 1;
    $node->title = 'Prepaid license';
    $node->field_product[LANGUAGE_NONE][]['product_id'] = $this->prepaid_product->product_id;
    node_save($node);
    $this->prepaid_product_display = $node;

    // Create a postpaid product that holds the license.
    $this->postpaid_product = $this->createProduct('POSTPAID-LICENSE-PLAN-A', 40, 'postpaid');
    // Create a product display for the postpaid product.
    $node = (object) array('type' => 'product_display');
    node_object_prepare($node);
    $node->uid = 1;
    $node->title = 'Postpaid license';
    $node->field_product[LANGUAGE_NONE][]['product_id'] = $this->postpaid_product->product_id;
    node_save($node);
    $this->postpaid_product_display = $node;

    // Create another postpaid product that serves as an alternative plan.
    $this->another_postpaid_product = $this->createProduct('POSTPAID-LICENSE-PLAN-B', 80, 'postpaid');

    $this->start = time();
  }

  /**
   * Main test function. Runs all of the subtests.
   *
   * Needed because SimpleTest reinstalls Drupal between test runs, but we
   * always need the results of the first checkout.
   */
  public function testRecurring() {
    $checkout_success = $this->checkoutTest();
    if ($checkout_success !== FALSE) {
      $this->planTest();
      $this->usageTest();
      $this->orderRefreshTest();
    }
  }

  /**
   * Tests the checkout process for prepaid and postpaid products.
   *
   * The process starts on the node page, and ends when checkout is complete,
   * the billing cycle has been opened, and the recurring order created with the
   * appropraite line items.
   */
  protected function checkoutTest() {
    $this->drupalLogin($this->store_customer);

    // Add the prepaid and postpaid products to cart.
    $this->drupalPost('node/' . $this->prepaid_product_display->nid, array(), t('Add to cart'));
    $this->drupalPost('node/' . $this->postpaid_product_display->nid, array(), t('Add to cart'));
    $this->drupalGet($this->getCommerceUrl('cart'));
    $this->assertText($this->prepaid_product->title, 'The prepaid license product is present in the cart view');
    $this->assertText($this->postpaid_product->title, 'The postpaid license product is present in the cart view');
    $this->assertText('$0.00', 'The postpaid license product is correctly priced at $0.00');

    // Complete checkout
    $this->completeCheckout();

    // Confirm that the recurring order for the billing cycle has been created.
    $has_recurring_order = FALSE;
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'commerce_order')
      ->entityCondition('bundle', 'recurring')
      ->fieldCondition('cl_billing_cycle', 'target_id', $this->billing_cycle->billing_cycle_id);
    $result = $query->execute();
    if ($result) {
      $order_id = key($result['commerce_order']);
      $has_recurring_order = TRUE;
    }
    $this->assertTrue($has_recurring_order, 'A recurring order matching the billing cycle has been created');
    if (!$has_recurring_order) {
      // If there's no recurring order, there's no point in further testing.
      return FALSE;
    }

    // Confirm the line items on the recurring order.
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'commerce_line_item')
      ->entityCondition('bundle', 'recurring')
      ->propertyCondition('order_id', $order_id);
    $result = $query->execute();
    if ($result) {
      $line_item_ids = array_keys($result['commerce_line_item']);
      $line_items = commerce_line_item_load_multiple($line_item_ids);
      // Key the line items by product_id.
      foreach ($line_items as $line_item) {
        $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
        $product_id = $line_item_wrapper->commerce_product->raw();
        $line_items_by_product[$product_id] = $line_item;
      }

      // Try to find the line item for the prepaid product.
      if (!empty($line_items_by_product[$this->prepaid_product->product_id])) {
        $line_item = $line_items_by_product[$this->prepaid_product->product_id];
        $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
        $this->assertTrue(TRUE, 'Found the recurring line item for the prepaid product.');

        $next_billing_cycle = $this->billing_cycle_type->getNextBillingCycle($this->billing_cycle, FALSE);
        $start = $line_item_wrapper->cl_billing_start->value();
        $end = $line_item_wrapper->cl_billing_end->value();
        $this->assertEqual($start, $next_billing_cycle->start, 'The recurring line item for the prepaid product has the correct start date');
        $this->assertEqual($end , $next_billing_cycle->end, 'The recurring line item for the prepaid product has the correct end date');

        $price_amount = $line_item_wrapper->commerce_unit_price->amount->value();
        $expected_price_amount = $this->prepaid_product->commerce_price[LANGUAGE_NONE][0]['amount'];
        $this->assertEqual($price_amount, $expected_price_amount, 'The recurring line item for the prepaid product has the correct price');
      }
      else {
        $this->assertTrue(FALSE, 'Found the recurring line item for the prepaid product.');
      }

      // Try to find the line item for the postpaid product.
      if (!empty($line_items_by_product[$this->postpaid_product->product_id])) {
        $line_item = $line_items_by_product[$this->postpaid_product->product_id];
        $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
        $this->assertTrue(TRUE, 'Found the recurring line item for the postpaid product.');

        $start = $line_item_wrapper->cl_billing_start->value();
        $end = $line_item_wrapper->cl_billing_end->value();
        $this->assertEqual($start, $this->billing_cycle->start, 'The recurring line item for the postpaid product has the correct start date');
        $this->assertEqual($end , $this->billing_cycle->end, 'The recurring line item for the postpaid product has the correct end date');

        $price_amount = $line_item_wrapper->commerce_unit_price->amount->value();
        $expected_price_amount = $this->postpaid_product->commerce_price[LANGUAGE_NONE][0]['amount'];
        $this->assertEqual($price_amount, $expected_price_amount, 'The recurring line item for the postpaid product has the correct price');
      }
      else {
        $this->assertTrue(FALSE, 'Found the recurring line item for the postpaid product.');
      }
    }
    else {
      $this->assertTrue(FALSE, 'The recurring order has two valid recurring line items');
    }

    return TRUE;
  }

  /**
   * Tests plan changes.
   */
  public function planTest() {
    $license = $this->getLicense('postpaid');

    // Switch from plan A to plan B.
    $plan_b_product_id = $this->another_postpaid_product->product_id;
    commerce_license_billing_change_plan($license, $plan_b_product_id);
    $plan_history = commerce_license_billing_plan_history_list($license, $this->billing_cycle);
    if (count($plan_history) < 2) {
      // The second record wasn't created, something went wrong, stop here.
      $this->assertTrue(FALSE, 'The second plan history record was successfuly opened');
      return;
    }

    $second_record_valid = FALSE;
    $product_ids_match = ($plan_history[1]['product_id'] == $plan_b_product_id);
    $start_times_match = ($plan_history[1]['start'] == REQUEST_TIME);
    $end_times_match = ($plan_history[1]['end'] == $this->billing_cycle->end);
    if ($product_ids_match && $start_times_match && $end_times_match) {
      $second_record_valid = TRUE;
    }
    $this->assertTrue($second_record_valid, 'The second plan history record is valid');
    $first_record_closed = ($plan_history[0]['end'] + 1 == $plan_history[1]['start']);
    $this->assertTrue($first_record_closed, 'The first plan history record was successfuly closed');
  }

  /**
   * Tests usage tracking.
   */
  protected function usageTest() {
    $prepaid_license = $this->getLicense('prepaid');
    $postpaid_license = $this->getLicense('postpaid');
    // Calculate the start and end timestamps of the usage.
    // The counter usage matches the first and second plan change.
    // (Counters can't be split across revisions currently).
    // The estimation usage goes across plans so that splitting can be tested
    // later in the process.
    $plan_history = commerce_license_billing_plan_history_list($prepaid_license, $this->billing_cycle);
    $billing_cycle_duration = $this->billing_cycle->end - $this->billing_cycle->start;
    $duration_part = ($billing_cycle_duration + 1) / 8;
    // In our case $billing_cycle->start comes before the first plan was
    // opened, so using that value would mean that the usage isn't mappable
    // to a revision, causing it to be left out.
    $first_usage_start = $plan_history[0]['start'];
    $second_usage_start =  $first_usage_start + ($duration_part * 2);
    $first_usage_end = $second_usage_start - 1;
    $second_usage_end = $this->billing_cycle->end;
    $third_usage_start = $plan_history[0]['start'];
    $fourth_usage_start = $third_usage_start + ($duration_part * 3);
    $third_usage_end = ($fourth_usage_start - 1);
    $fourth_usage_end = $this->billing_cycle->end;
    // Remember this start so that it can be confirmed on the line item.
    $this->fourth_usage_start = $fourth_usage_start;

    // Add counter usage.
    commerce_license_billing_usage_add($prepaid_license, 'bandwidth', 2050, $first_usage_start, $first_usage_end);
    commerce_license_billing_usage_add($prepaid_license, 'bandwidth', 1022, $second_usage_start, $second_usage_end);
    // Confirm the correct current usage.
    $current_usage = commerce_license_billing_current_usage($prepaid_license, 'bandwidth');
    $this->assertEqual($current_usage, 3072, 'Current bandwidth usage matches total reported quantity');

    // Open usage for environments.
    commerce_license_billing_usage_add($postpaid_license, 'environments', 1, $third_usage_start, $third_usage_end);
    commerce_license_billing_usage_add($postpaid_license, 'environments', 3, $fourth_usage_start, $fourth_usage_end);
    // Confirm that the first usage was correctly closed.
    $usage_history = commerce_license_billing_usage_history_list($postpaid_license, $this->billing_cycle);
    $first_record_closed = ($usage_history[0]['end'] + 1 == $usage_history[1]['start']);
    $this->assertTrue($first_record_closed, 'The first environment usage history record was successfuly closed');
    // Confirm the correct current usage.
    $current_usage = commerce_license_billing_current_usage($postpaid_license, 'environments');
    $this->assertEqual($current_usage, 3, 'Current environment usage matches last reported quantity');
  }

  /**
   * Tests the recurring order refresh and its pricing logic.
   */
  protected function orderRefreshTest() {
    $prepaid_license = $this->getLicense('prepaid');
    $postpaid_license = $this->getLicense('postpaid');

    // Tweak the revisions so that the plan changes can be prorated.
    // First plan: 1/4 of the billing cycle, second plan 2/4, suspend 1/8,
    // reactive second plan 1/8.
    $billing_cycle_duration = $this->billing_cycle->end - $this->billing_cycle->start;
    $duration_part = ($billing_cycle_duration + 1) / 8;
    $first_plan_start = $this->billing_cycle->start;
    $second_plan_start = $first_plan_start + ($duration_part * 2);
    $suspension_start = $first_plan_start + ($duration_part * 4);
    $reactivation_start = $first_plan_start + ($duration_part * 7);
    $plan_durations = array();
    $plan_durations[] = array($first_plan_start, $second_plan_start - 1);
    $plan_durations[] = array($second_plan_start, $suspension_start - 1);
    $plan_durations[] = array($suspension_start, $reactivation_start - 1);
    $plan_durations[] = array($reactivation_start, 0);

    // The postpaid license has already had a plan shift from A to B, so
    // there are two revisions that should be updated.
    $data = array(
      'license_id' => $postpaid_license->license_id,
      'status' => COMMERCE_LICENSE_ACTIVE,
    );
    $revision_ids = db_query('SELECT revision_id from {commerce_license_revision}
                                WHERE license_id = :license_id AND status = :status
                                  ORDER BY revision_id ASC', $data)->fetchAll(PDO::FETCH_ASSOC);
    db_update('commerce_license_revision')
      ->fields(array(
        'revision_created' => $plan_durations[0][0],
        'revision_ended' => $plan_durations[0][1],
      ))
      ->condition('revision_id', $revision_ids[0]['revision_id'])
      ->execute();
    db_update('commerce_license_revision')
      ->fields(array(
        'revision_created' => $plan_durations[1][0],
        // Since the second revision is still active, its end should be 0.
        'revision_ended' => 0,
      ))
      ->condition('revision_id', $revision_ids[1]['revision_id'])
      ->execute();

    // Trigger an order refresh.
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'commerce_order')
      ->entityCondition('bundle', 'recurring')
      ->fieldCondition('cl_billing_cycle', 'target_id', $this->billing_cycle->billing_cycle_id);
    $result = $query->execute();
    $order_id = key($result['commerce_order']);
    drupal_static_reset('commerce_license_billing_plan_history_list');
    $recurring_order = commerce_order_load($order_id);

    // Build an array of expected line items.
    $next_billing_cycle = $this->billing_cycle_type->getNextBillingCycle($this->billing_cycle);
    $expected_line_items = array();
    // The prepaid product.
    $expected_line_items[] = array(
      'title' => 'prepaid base product',
      'product_id' => $this->prepaid_product->product_id,
      'unit_price' => $this->prepaid_product->commerce_price[LANGUAGE_NONE][0]['amount'],
      'quantity' => 1,
      'start' => $next_billing_cycle->start,
      'end' => $next_billing_cycle->end,
    );
    // The counter usage.
    $counter_product = commerce_product_load_by_sku('BILLING-TEST-BANDWIDTH');
    $expected_line_items[] = array(
      'title' => 'counter usage product',
      'product_id' => $counter_product->product_id,
      'unit_price' => $counter_product->commerce_price[LANGUAGE_NONE][0]['amount'],
      // 1024 is free, the rest is charged for.
      'quantity' => 2048,
      'start' => $this->billing_cycle->start,
      'end' => $this->billing_cycle->end,
    );
    // The plans of the postpaid product.
    $expected_line_items[] = array(
      'title' => 'postpaid base product (plan A)',
      'product_id' => $this->postpaid_product->product_id,
      'unit_price' => '1000', // 10$
      'quantity' => 1,
      'start' => $plan_durations[0][0],
      'end' => $plan_durations[0][1],
    );
    // The second plan hasn't been closed yet, so it's taking 3/4 of the cycle.
    $expected_line_items[] = array(
      'title' => 'postpaid base product (plan B)',
      'product_id' => $this->another_postpaid_product->product_id,
      'unit_price' => '6000', // 60$
      'quantity' => 1,
      'start' => $plan_durations[1][0],
      'end' => $this->billing_cycle->end,
    );
    $env_product = commerce_product_load_by_sku('BILLING-TEST-ENV');
    $expected_line_items[] = array(
      'title' => 'environments usage product',
      'product_id' => $env_product->product_id,
      'unit_price' => '625', // 6.25$
      'quantity' => 3,
      'start' => $this->fourth_usage_start,
      'end' => $this->billing_cycle->end,
    );
    $this->assertLineItems($recurring_order, $expected_line_items);

    // Suspend and reactivate the postpaid license, ensure a new line item
    // was added with the last 1/8 of the plan history priced.
    $postpaid_license->status = COMMERCE_LICENSE_SUSPENDED;
    $postpaid_license->save();
    $postpaid_license->status = COMMERCE_LICENSE_ACTIVE;
    $postpaid_license->save();

    $data = array(
      'license_id' => $postpaid_license->license_id,
    );
    $revision_ids = db_query('SELECT * from {commerce_license_revision}
                                WHERE license_id = :license_id
                                  ORDER BY revision_id ASC', $data)->fetchAll(PDO::FETCH_ASSOC);
    // Close the previous active revision.
    db_update('commerce_license_revision')
      ->fields(array(
        'revision_created' => $plan_durations[1][0],
        'revision_ended' => $plan_durations[1][1],
      ))
      ->condition('revision_id', $revision_ids[1]['revision_id'])
      ->execute();
    // Update the suspended revision.
    db_update('commerce_license_revision')
      ->fields(array(
        'revision_created' => $plan_durations[2][0],
        'revision_ended' => $plan_durations[2][1],
      ))
      ->condition('revision_id', $revision_ids[2]['revision_id'])
      ->execute();
    // Update the new active revision.
    db_update('commerce_license_revision')
      ->fields(array(
        'revision_created' => $plan_durations[3][0],
        'revision_ended' => 0,
      ))
      ->condition('revision_id', $revision_ids[3]['revision_id'])
      ->execute();

    // The previous active revision went from 3/4 to 1/4 of the billing cycle
    // so the expected price needs to change.
    $expected_line_items[3]['end'] = $plan_durations[1][1];
    $expected_line_items[3]['unit_price'] = '2000'; // 20$.
    unset($expected_line_items[4]);
    // Add the new active plan.
    $expected_line_items[] = array(
      'title' => 'postpaid base product (plan B)',
      'product_id' => $this->another_postpaid_product->product_id,
      'unit_price' => '1000', // 10$
      'quantity' => 1,
      'start' => $plan_durations[3][0],
      'end' => $this->billing_cycle->end,
    );
    $expected_line_items[] = array(
      'title' => 'environments usage product',
      'product_id' => $env_product->product_id,
      'unit_price' => '125',
      'quantity' => 3,
      'start' => $this->fourth_usage_start,
      'end' => $plan_durations[1][1],
    );
    $expected_line_items[] = array(
      'title' => 'environments usage product',
      'product_id' => $env_product->product_id,
      'unit_price' => '125',
      'quantity' => 3,
      'start' => $plan_durations[3][0],
      'end' => $this->billing_cycle->end,
    );
    $expected_line_items = array_values($expected_line_items);

    // Reload the order and re-examine the line items.
    entity_get_controller('commerce_order')->resetCache();
    drupal_static_reset('commerce_license_billing_commerce_order_load');
    drupal_static_reset('commerce_license_billing_plan_history_list');
    $recurring_order = commerce_order_load($order_id);
    $this->assertLineItems($recurring_order, $expected_line_items);
  }

  /**
   * Get the license for the provided billing type.
   *
   * @param $billing_type
   *   The billing type (prepaid or postpaid).
   *
   * @return
   *   The loaded license entity, or FALSE if not found.
   */
  protected function getLicense($billing_type) {
    $product_ids = array();
    if ($billing_type == 'prepaid') {
      $product_ids[] = $this->prepaid_product->product_id;
    }
    else {
      $product_ids[] = $this->postpaid_product->product_id;
      $product_ids[] = $this->another_postpaid_product->product_id;
    }

    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'commerce_license')
      ->propertyCondition('product_id', $product_ids);
    $result = $query->execute();
    $license_id = key($result['commerce_license']);

    return entity_load_single('commerce_license', $license_id);
  }

  /**
   * Create and save a recurring product.
   *
   * @param $sku
   *   The sku of the new product.
   * @param $price
   *   The price of the new product.
   * @param $billing_type
   *   The billing type (prepaid or postpaid).
   *
   * @return
   *   The newly saved product.
   */
  protected function createProduct($sku, $price, $billing_type) {
    $product = commerce_product_new('product');
    $product->sku = $sku;
    $product->title = str_replace('-', ' ', ucfirst(strtolower($sku)));
    $product->uid = 1;
    $product->commerce_price[LANGUAGE_NONE][0]['amount'] = $price * 100;
    $product->commerce_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';
    $product->commerce_license_type[LANGUAGE_NONE][0]['value'] = 'billing_test';
    $product->commerce_license_duration[LANGUAGE_NONE][0]['value'] = 0;
    $product->cl_billing_cycle_type[LANGUAGE_NONE][0]['target_id'] = $this->billing_cycle_type->billing_cycle_type_id;
    $product->cl_billing_type[LANGUAGE_NONE][0]['value'] = $billing_type;
    commerce_product_save($product);

    return $product;
  }

  /**
   * Completes checkout.
   */
  protected function completeCheckout() {
    $this->drupalGet($this->getCommerceUrl('checkout'));
    $address_info = $this->generateAddressInformation();
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
    );
    $this->drupalPost(NULL, $info, 'Continue to next step');
    $this->drupalPost(NULL, array(), 'Continue to next step');
    $this->drupalPost(NULL, array('commerce_payment[payment_details][name]' => 'Example payment method'), 'Continue to next step');
    $this->assertTitle('Checkout complete' . ' | Drupal', 'Checkout has been completed');
  }

  /**
   * Asserts that the provided order has the expected line items.
   *
   * @param $order
   *   The order entity
   * @param $expected_line_items
   *   An array of arrays with the title, product_id, price, start, end keys.
   */
  protected function assertLineItems($order, $expected_line_items) {
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    foreach ($expected_line_items as $index => $expected_line_item) {
      $match = FALSE;
      if (isset($order_wrapper->commerce_line_items[$index])) {
        $wrapper = $order_wrapper->commerce_line_items[$index];
        $product_matches = ($wrapper->commerce_product->raw() == $expected_line_item['product_id']);
        $price_matches = ($wrapper->commerce_unit_price->amount->value() == $expected_line_item['unit_price']);
        $quantity_matches = ($wrapper->quantity->value() == $expected_line_item['quantity']);
        $start_matches = ($wrapper->cl_billing_start->value() == $expected_line_item['start']);
        $end_matches = ($wrapper->cl_billing_end->value() == $expected_line_item['end']);
        $match = ($product_matches && $price_matches && $quantity_matches && $start_matches && $end_matches);
      }
      $this->assertTrue($match, 'Found valid matching line item for ' . $expected_line_item['title']);
    }
  }
}
